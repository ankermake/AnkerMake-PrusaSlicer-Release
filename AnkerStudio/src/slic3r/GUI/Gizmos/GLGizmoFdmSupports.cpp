#include "GLGizmoFdmSupports.hpp"

#include "libslic3r/Model.hpp"

//#include "slic3r/GUI/3DScene.hpp"
#include "libslic3r/SupportSpotsGenerator.hpp"
#include "libslic3r/TriangleSelectorWrapper.hpp"
#include "slic3r/GUI/GLCanvas3D.hpp"
#include "slic3r/GUI/GUI_App.hpp"
#include "slic3r/GUI/ImGuiWrapper.hpp"
#include "slic3r/GUI/Plater.hpp"
#include "slic3r/GUI/GUI_ObjectList.hpp"
#include "slic3r/GUI/format.hpp"
#include "slic3r/Utils/UndoRedo.hpp"
#include "libslic3r/Print.hpp"
#include "slic3r/GUI/MsgDialog.hpp"
#include "slic3r/GUI/Common/AnkerTitledPanel.hpp"
#include "slic3r/GUI/Common/AnkerGUIConfig.hpp"
#include "slic3r/GUI/Common/AnkerSplitCtrl.hpp"

#include <wx/valnum.h>
#include <GL/glew.h>

#define BTN_PRESSED "pressed"
#define BTN_NORMAL "normal"

namespace Slic3r::GUI {



	/*void GLGizmoFdmSupports::on_shutdown()
	{
		m_highlight_by_angle_threshold_deg = 0.f;
		m_parent.use_slope(false);
		m_parent.toggle_model_objects_visibility(true);
	}*/



	std::string GLGizmoFdmSupports::on_get_name(bool i18n) const
	{
		return i18n ? _u8L("Paint-on supports") : "Paint-on supports";
	}



	bool GLGizmoFdmSupports::on_init()
	{
		m_shortcut_key = WXK_CONTROL_L;

		m_desc["autopaint"] = _L("Automatic painting");
		// TRN GizmoFdmSupports : message line during the waiting for autogenerated supports
		m_desc["painting"] = _L("painting") + dots;
		m_desc["clipping_of_view"] = _L("Clipping of view") + ": ";
		m_desc["reset_direction"] = _L("Reset direction");
		m_desc["cursor_size"] = _L("Brush size") + ": ";
		m_desc["cursor_type"] = _L("Brush shape") + ": ";
		m_desc["enforce_caption"] = _L("Left mouse button") + ": ";
		m_desc["enforce"] = _L("Enforce supports");
		m_desc["block_caption"] = _L("Right mouse button") + ": ";
		m_desc["block"] = _L("Block supports");
		m_desc["remove_caption"] = _L("Shift + Left mouse button") + ": ";
		m_desc["remove"] = _L("Remove selection");
		m_desc["remove_all"] = _L("Remove all selection");
		m_desc["circle"] = _L("Circle");
		m_desc["sphere"] = _L("Sphere");
		m_desc["pointer"] = _L("Triangles");
		m_desc["highlight_by_angle"] = _L("Highlight overhang by angle");
		m_desc["enforce_button"] = _L("Enforce");
		m_desc["cancel"] = _L("Cancel");

		m_desc["tool_type"] = _L("Tool type") + ": ";
		m_desc["tool_brush"] = _L("Brush");
		m_desc["tool_smart_fill"] = _L("Smart fill");

		m_desc["smart_fill_angle"] = _L("Smart fill angle");

		m_desc["split_triangles"] = _L("Split triangles");
		m_desc["on_overhangs_only"] = _L("On overhangs only");

		return true;
	}

	void GLGizmoFdmSupports::render_painter_gizmo()
	{
		const Selection& selection = m_parent.get_selection();

		glsafe(::glEnable(GL_BLEND));
		glsafe(::glEnable(GL_DEPTH_TEST));

		render_triangles(selection);
		m_c->object_clipper()->render_cut();
		m_c->instances_hider()->render_cut();
		render_cursor();

		glsafe(::glDisable(GL_BLEND));
	}



	void GLGizmoFdmSupports::on_render_input_window(float x, float y, float bottom_limit)
	{
		if (!m_c->selection_info()->model_object())
			return;

		const float approx_height = m_imgui->scaled(25.f);
		y = std::min(y, bottom_limit - approx_height);
		m_imgui->set_next_window_pos(x, y, ImGuiCond_Always);

		m_imgui->begin(get_name(), ImGuiWindowFlags_NoMove | ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoCollapse);

		// First calculate width of all the texts that are could possibly be shown. We will decide set the dialog width based on that:
		const float clipping_slider_left = std::max(m_imgui->calc_text_size(m_desc.at("clipping_of_view")).x,
			m_imgui->calc_text_size(m_desc.at("reset_direction")).x) + m_imgui->scaled(1.5f);
		const float cursor_slider_left = m_imgui->calc_text_size(m_desc.at("cursor_size")).x + m_imgui->scaled(1.f);
		const float smart_fill_slider_left = m_imgui->calc_text_size(m_desc.at("smart_fill_angle")).x + m_imgui->scaled(1.f);
		const float autoset_slider_label_max_width = m_imgui->scaled(7.5f);
		const float autoset_slider_left = m_imgui->calc_text_size(m_desc.at("highlight_by_angle"), autoset_slider_label_max_width).x + m_imgui->scaled(1.f);

		const float cursor_type_radio_circle = m_imgui->calc_text_size(m_desc["circle"]).x + m_imgui->scaled(2.5f);
		const float cursor_type_radio_sphere = m_imgui->calc_text_size(m_desc["sphere"]).x + m_imgui->scaled(2.5f);
		const float cursor_type_radio_pointer = m_imgui->calc_text_size(m_desc["pointer"]).x + m_imgui->scaled(2.5f);

		const float button_width = m_imgui->calc_text_size(m_desc.at("remove_all")).x + m_imgui->scaled(1.f);
		const float button_enforce_width = m_imgui->calc_text_size(m_desc.at("enforce_button")).x;
		const float button_cancel_width = m_imgui->calc_text_size(m_desc.at("cancel")).x;
		const float buttons_width = std::max(button_enforce_width, button_cancel_width) + m_imgui->scaled(0.5f);
		const float minimal_slider_width = m_imgui->scaled(4.f);

		const float tool_type_radio_left = m_imgui->calc_text_size(m_desc["tool_type"]).x + m_imgui->scaled(1.f);
		const float tool_type_radio_brush = m_imgui->calc_text_size(m_desc["tool_brush"]).x + m_imgui->scaled(2.5f);
		const float tool_type_radio_smart_fill = m_imgui->calc_text_size(m_desc["tool_smart_fill"]).x + m_imgui->scaled(2.5f);

		const float split_triangles_checkbox_width = m_imgui->calc_text_size(m_desc["split_triangles"]).x + m_imgui->scaled(2.5f);
		const float on_overhangs_only_checkbox_width = m_imgui->calc_text_size(m_desc["on_overhangs_only"]).x + m_imgui->scaled(2.5f);

		float caption_max = 0.f;
		float total_text_max = 0.f;
		for (const auto& t : std::array<std::string, 3>{"enforce", "block", "remove"}) {
			caption_max = std::max(caption_max, m_imgui->calc_text_size(m_desc[t + "_caption"]).x);
			total_text_max = std::max(total_text_max, m_imgui->calc_text_size(m_desc[t]).x);
		}
		total_text_max += caption_max + m_imgui->scaled(1.f);
		caption_max += m_imgui->scaled(1.f);

		const float sliders_left_width = std::max(std::max(autoset_slider_left, smart_fill_slider_left), std::max(cursor_slider_left, clipping_slider_left));
		const float slider_icon_width = m_imgui->get_slider_icon_size().x;
		float       window_width = minimal_slider_width + sliders_left_width + slider_icon_width;
		window_width = std::max(window_width, total_text_max);
		window_width = std::max(window_width, button_width);
		window_width = std::max(window_width, split_triangles_checkbox_width);
		window_width = std::max(window_width, on_overhangs_only_checkbox_width);
		window_width = std::max(window_width, cursor_type_radio_circle + cursor_type_radio_sphere + cursor_type_radio_pointer);
		window_width = std::max(window_width, tool_type_radio_left + tool_type_radio_brush + tool_type_radio_smart_fill);
		window_width = std::max(window_width, 2.f * buttons_width + m_imgui->scaled(1.f));

		auto draw_text_with_caption = [this, &caption_max](const wxString& caption, const wxString& text) {
			m_imgui->text_colored(ImGuiWrapper::COL_ORANGE_LIGHT, caption);
			ImGui::SameLine(caption_max);
			m_imgui->text(text);
		};

		for (const auto& t : std::array<std::string, 3>{"enforce", "block", "remove"})
			draw_text_with_caption(m_desc.at(t + "_caption"), m_desc.at(t));

		ImGui::Separator();

		if (waiting_for_autogenerated_supports) {
			m_imgui->text(m_desc.at("painting"));
		}
		else {
			bool generate = m_imgui->button(m_desc.at("autopaint"));
			if (generate)
				auto_generate();
		}
		ImGui::Separator();

		float position_before_text_y = ImGui::GetCursorPos().y;
		ImGui::AlignTextToFramePadding();
		m_imgui->text_wrapped(m_desc["highlight_by_angle"] + ":", autoset_slider_label_max_width);
		ImGui::AlignTextToFramePadding();
		float position_after_text_y = ImGui::GetCursorPos().y;
		std::string format_str = std::string("%.f") + I18N::translate_utf8("Â°",
			"Degree sign to use in the respective slider in FDM supports gizmo,"
			"placed after the number with no whitespace in between.");
		ImGui::SameLine(sliders_left_width);

		float slider_height = m_imgui->get_slider_float_height();
		// Makes slider to be aligned to bottom of the multi-line text.
		float slider_start_position_y = std::max(position_before_text_y, position_after_text_y - slider_height);
		ImGui::SetCursorPosY(slider_start_position_y);

		ImGui::PushItemWidth(window_width - sliders_left_width - slider_icon_width);
		wxString tooltip = format_wxstr(_L("Preselects faces by overhang angle. It is possible to restrict paintable facets to only preselected faces when "
			"the option \"%1%\" is enabled."), m_desc["on_overhangs_only"]);
		if (m_imgui->slider_float("##angle_threshold_deg", &m_highlight_by_angle_threshold_deg, 0.f, 90.f, format_str.data(), 1.0f, true, tooltip)) {
			m_parent.set_slope_normal_angle(90.f - m_highlight_by_angle_threshold_deg);
			if (!m_parent.is_using_slope()) {
				m_parent.use_slope(true);
				m_parent.set_as_dirty();
			}
		}

		// Restores the cursor position to be below the multi-line text.
		ImGui::SetCursorPosY(std::max(position_before_text_y + slider_height, position_after_text_y));

		const float max_tooltip_width = ImGui::GetFontSize() * 20.0f;

		m_imgui->disabled_begin(m_highlight_by_angle_threshold_deg == 0.f);
		ImGui::NewLine();
		ImGui::SameLine(window_width - 2.f * buttons_width - m_imgui->scaled(0.5f));
		if (m_imgui->button(m_desc["enforce_button"], buttons_width, 0.f)) {
			select_facets_by_angle(m_highlight_by_angle_threshold_deg, false);
			m_highlight_by_angle_threshold_deg = 0.f;
			m_parent.use_slope(false);
		}
		ImGui::SameLine(window_width - buttons_width);
		if (m_imgui->button(m_desc["cancel"], buttons_width, 0.f)) {
			m_highlight_by_angle_threshold_deg = 0.f;
			m_parent.use_slope(false);
		}
		m_imgui->disabled_end();


		ImGui::Separator();

		ImGui::AlignTextToFramePadding();
		m_imgui->text(m_desc["tool_type"]);

		float tool_type_offset = tool_type_radio_left + (window_width - tool_type_radio_left - tool_type_radio_brush - tool_type_radio_smart_fill + m_imgui->scaled(0.5f)) / 2.f;
		ImGui::SameLine(tool_type_offset);
		ImGui::PushItemWidth(tool_type_radio_brush);
		if (m_imgui->radio_button(m_desc["tool_brush"], m_tool_type == ToolType::BRUSH))
			m_tool_type = ToolType::BRUSH;

		if (ImGui::IsItemHovered())
			m_imgui->tooltip(_L("Paints facets according to the chosen painting brush."), max_tooltip_width);

		ImGui::SameLine(tool_type_offset + tool_type_radio_brush);
		ImGui::PushItemWidth(tool_type_radio_smart_fill);
		if (m_imgui->radio_button(m_desc["tool_smart_fill"], m_tool_type == ToolType::SMART_FILL))
			m_tool_type = ToolType::SMART_FILL;

		if (ImGui::IsItemHovered())
			m_imgui->tooltip(_L("Paints neighboring facets whose relative angle is less or equal to set angle."), max_tooltip_width);

		m_imgui->checkbox(m_desc["on_overhangs_only"], m_paint_on_overhangs_only);
		if (ImGui::IsItemHovered())
			m_imgui->tooltip(format_wxstr(_L("Allows painting only on facets selected by: \"%1%\""), m_desc["highlight_by_angle"]), max_tooltip_width);

		ImGui::Separator();

		if (m_tool_type == ToolType::BRUSH) {
			m_imgui->text(m_desc.at("cursor_type"));
			ImGui::NewLine();

			float cursor_type_offset = (window_width - cursor_type_radio_sphere - cursor_type_radio_circle - cursor_type_radio_pointer + m_imgui->scaled(1.5f)) / 2.f;
			ImGui::SameLine(cursor_type_offset);
			ImGui::PushItemWidth(cursor_type_radio_sphere);
			if (m_imgui->radio_button(m_desc["sphere"], m_cursor_type == TriangleSelector::CursorType::SPHERE))
				m_cursor_type = TriangleSelector::CursorType::SPHERE;

			if (ImGui::IsItemHovered())
				m_imgui->tooltip(_L("Paints all facets inside, regardless of their orientation."), max_tooltip_width);

			ImGui::SameLine(cursor_type_offset + cursor_type_radio_sphere);
			ImGui::PushItemWidth(cursor_type_radio_circle);

			if (m_imgui->radio_button(m_desc["circle"], m_cursor_type == TriangleSelector::CursorType::CIRCLE))
				m_cursor_type = TriangleSelector::CursorType::CIRCLE;

			if (ImGui::IsItemHovered())
				m_imgui->tooltip(_L("Ignores facets facing away from the camera."), max_tooltip_width);

			ImGui::SameLine(cursor_type_offset + cursor_type_radio_sphere + cursor_type_radio_circle);
			ImGui::PushItemWidth(cursor_type_radio_pointer);

			if (m_imgui->radio_button(m_desc["pointer"], m_cursor_type == TriangleSelector::CursorType::POINTER))
				m_cursor_type = TriangleSelector::CursorType::POINTER;

			if (ImGui::IsItemHovered())
				m_imgui->tooltip(_L("Paints only one facet."), max_tooltip_width);

			m_imgui->disabled_begin(m_cursor_type != TriangleSelector::CursorType::SPHERE && m_cursor_type != TriangleSelector::CursorType::CIRCLE);

			ImGui::AlignTextToFramePadding();
			m_imgui->text(m_desc.at("cursor_size"));
			ImGui::SameLine(sliders_left_width);
			ImGui::PushItemWidth(window_width - sliders_left_width - slider_icon_width);
			m_imgui->slider_float("##cursor_radius", &m_cursor_radius, CursorRadiusMin, CursorRadiusMax, "%.2f", 1.0f, true, _L("Alt + Mouse wheel"));

			m_imgui->checkbox(m_desc["split_triangles"], m_triangle_splitting_enabled);

			if (ImGui::IsItemHovered())
				m_imgui->tooltip(_L("Splits bigger facets into smaller ones while the object is painted."), max_tooltip_width);

			m_imgui->disabled_end();
		}
		else {
			assert(m_tool_type == ToolType::SMART_FILL);
			ImGui::AlignTextToFramePadding();
			m_imgui->text(m_desc["smart_fill_angle"] + ":");

			ImGui::SameLine(sliders_left_width);
			ImGui::PushItemWidth(window_width - sliders_left_width - slider_icon_width);
			if (m_imgui->slider_float("##smart_fill_angle", &m_smart_fill_angle, SmartFillAngleMin, SmartFillAngleMax, format_str.data(), 1.0f, true, _L("Alt + Mouse wheel")))
				for (auto& triangle_selector : m_triangle_selectors) {
					triangle_selector->seed_fill_unselect_all_triangles();
					triangle_selector->request_update_render_data();
				}
		}

		ImGui::Separator();
		if (m_c->object_clipper()->get_position() == 0.f) {
			ImGui::AlignTextToFramePadding();
			m_imgui->text(m_desc.at("clipping_of_view"));
		}
		else {
			if (m_imgui->button(m_desc.at("reset_direction"))) {
				wxGetApp().CallAfter([this]() {
					m_c->object_clipper()->set_position_by_ratio(-1., false);
					});
			}
		}

		auto clp_dist = float(m_c->object_clipper()->get_position());
		ImGui::SameLine(sliders_left_width);
		ImGui::PushItemWidth(window_width - sliders_left_width - slider_icon_width);
		if (m_imgui->slider_float("##clp_dist", &clp_dist, 0.f, 1.f, "%.2f", 1.0f, true, _L("Ctrl + Mouse wheel")))
			m_c->object_clipper()->set_position_by_ratio(clp_dist, true);

		ImGui::Separator();
		if (m_imgui->button(m_desc.at("remove_all"))) {
			Plater::TakeSnapshot snapshot(wxGetApp().plater(), _L("Reset selection"), UndoRedo::SnapshotType::GizmoAction);
			ModelObject* mo = m_c->selection_info()->model_object();
			int                  idx = -1;
			for (ModelVolume* mv : mo->volumes)
				if (mv->is_model_part()) {
					++idx;
					m_triangle_selectors[idx]->reset();
					m_triangle_selectors[idx]->request_update_render_data();
				}

			update_model_object();
			this->waiting_for_autogenerated_supports = false;
			m_parent.set_as_dirty();
		}

		m_imgui->end();
	}



	void GLGizmoFdmSupports::select_facets_by_angle(float threshold_deg, bool block)
	{
		float threshold = (float(M_PI) / 180.f) * threshold_deg;
		const Selection& selection = m_parent.get_selection();
		const ModelObject* mo = m_c->selection_info()->model_object();
		const ModelInstance* mi = mo->instances[selection.get_instance_idx()];

		int mesh_id = -1;
		for (const ModelVolume* mv : mo->volumes) {
			if (!mv->is_model_part())
				continue;

			++mesh_id;

			const Transform3d trafo_matrix = mi->get_matrix_no_offset() * mv->get_matrix_no_offset();
			Vec3f down = (trafo_matrix.inverse() * (-Vec3d::UnitZ())).cast<float>().normalized();
			Vec3f limit = (trafo_matrix.inverse() * Vec3d(std::sin(threshold), 0, -std::cos(threshold))).cast<float>().normalized();

			float dot_limit = limit.dot(down);

			// Now calculate dot product of vert_direction and facets' normals.
			int idx = 0;
			const indexed_triangle_set& its = mv->mesh().its;
			for (const stl_triangle_vertex_indices& face : its.indices) {
				if (its_face_normal(its, face).dot(down) > dot_limit) {
					m_triangle_selectors[mesh_id]->set_facet(idx, block ? EnforcerBlockerType::BLOCKER : EnforcerBlockerType::ENFORCER);
					m_triangle_selectors.back()->request_update_render_data();
				}
				++idx;
			}
		}

		Plater::TakeSnapshot snapshot(wxGetApp().plater(), block ? _L("Block supports by angle")
			: _L("Add supports by angle"));
		update_model_object();
		this->waiting_for_autogenerated_supports = false;
		m_parent.set_as_dirty();
	}

	void GLGizmoFdmSupports::data_changed()
	{
		GLGizmoPainterBase::data_changed();
		if (!m_c->selection_info())
			return;

		ModelObject* mo = m_c->selection_info()->model_object();
		if (mo && this->waiting_for_autogenerated_supports) {
			apply_data_from_backend();
		}
		else {
			this->waiting_for_autogenerated_supports = false;
		}

		sync_data_from_param_panel();
	}

	void GLGizmoFdmSupports::apply_data_from_backend()
	{
		if (!has_backend_supports())
			return;
		ModelObject* mo = m_c->selection_info()->model_object();
		if (!mo) {
			this->waiting_for_autogenerated_supports = false;
			return;
		}

		// find the respective PrintObject, we need a pointer to it
		for (const PrintObject* po : m_parent.fff_print()->objects()) {
			if (po->model_object()->id() == mo->id()) {
				std::unordered_map<size_t, TriangleSelectorWrapper> selectors;
				SupportSpotsGenerator::SupportPoints support_points = po->shared_regions()->generated_support_points->support_points;
				auto                                 obj_transform = po->shared_regions()->generated_support_points->object_transform;
				for (ModelVolume* model_volume : po->model_object()->volumes) {
					if (model_volume->is_model_part()) {
						Transform3d mesh_transformation = obj_transform * model_volume->get_matrix();
						Transform3d inv_transform = mesh_transformation.inverse();
						selectors.emplace(model_volume->id().id, TriangleSelectorWrapper{ model_volume->mesh(), mesh_transformation });

						for (const SupportSpotsGenerator::SupportPoint& support_point : support_points) {
							Vec3f point = Vec3f(inv_transform.cast<float>() * support_point.position);
							Vec3f origin = Vec3f(inv_transform.cast<float>() *
								Vec3f(support_point.position.x(), support_point.position.y(), 0.0f));
							selectors.at(model_volume->id().id).enforce_spot(point, origin, support_point.spot_radius);
						}
					}
				}

				int mesh_id = -1.0f;
				for (ModelVolume* mv : mo->volumes) {
					if (mv->is_model_part()) {
						mesh_id++;
						auto selector = selectors.find(mv->id().id);
						if (selector != selectors.end()) {
							mv->supported_facets.set(selector->second.selector);
							m_triangle_selectors[mesh_id]->deserialize(mv->supported_facets.get_data(), true);
							m_triangle_selectors[mesh_id]->request_update_render_data();
						}
					}
				}

				m_parent.post_event(SimpleEvent(EVT_GLCANVAS_SCHEDULE_BACKGROUND_PROCESS));
				m_parent.set_as_dirty();
			}
			this->waiting_for_autogenerated_supports = false;
		}
	}

	void GLGizmoFdmSupports::update_model_object() const
	{
		bool updated = false;
		ModelObject* mo = m_c->selection_info()->model_object();
		int idx = -1;
		for (ModelVolume* mv : mo->volumes) {
			if (!mv->is_model_part())
				continue;
			++idx;
			updated |= mv->supported_facets.set(*m_triangle_selectors[idx].get());
		}

		if (updated) {
			const ModelObjectPtrs& mos = wxGetApp().model().objects;
			wxGetApp().objectbar()->update_info_items(std::find(mos.begin(), mos.end(), mo) - mos.begin(), AnkerObjectItem::ITYPE_SUPPORT);

			m_parent.post_event(SimpleEvent(EVT_GLCANVAS_SCHEDULE_BACKGROUND_PROCESS));
		}
	}

	void GLGizmoFdmSupports::update_from_model_object()
	{
		wxBusyCursor wait;

		const ModelObject* mo = m_c->selection_info()->model_object();
		m_triangle_selectors.clear();

		int volume_id = -1;
		for (const ModelVolume* mv : mo->volumes) {
			if (!mv->is_model_part())
				continue;

			++volume_id;

			// This mesh does not account for the possible Z up SLA offset.
			const TriangleMesh* mesh = &mv->mesh();

			m_triangle_selectors.emplace_back(std::make_unique<TriangleSelectorGUI>(*mesh));
			// Reset of TriangleSelector is done inside TriangleSelectorGUI's constructor, so we don't need it to perform it again in deserialize().
			m_triangle_selectors.back()->deserialize(mv->supported_facets.get_data(), false);
			m_triangle_selectors.back()->request_update_render_data();
		}
	}

	bool GLGizmoFdmSupports::has_backend_supports()
	{
		const ModelObject* mo = m_c->selection_info()->model_object();
		if (!mo) {
			waiting_for_autogenerated_supports = false;
			return false;
		}

		// find PrintObject with this ID
		bool done = false;
		for (const PrintObject* po : m_parent.fff_print()->objects()) {
			if (po->model_object()->id() == mo->id())
				done = done || po->is_step_done(posSupportSpotsSearch);
		}

		if (!done && !wxGetApp().plater()->is_background_process_update_scheduled()) {
			waiting_for_autogenerated_supports = false;
		}

		return done;
	}

	void GLGizmoFdmSupports::auto_generate()
	{
		std::string err = wxGetApp().plater()->fff_print().validate();
		if (!err.empty()) {
			MessageDialog dlg(GUI::wxGetApp().plater(), _L("Automatic painting requires valid print setup.") + " \n" + from_u8(err), _L("Warning"), wxOK);
			dlg.ShowModal();
			return;
		}

		ModelObject* mo = m_c->selection_info()->model_object();
		bool not_painted = std::all_of(mo->volumes.begin(), mo->volumes.end(), [](const ModelVolume* vol) {
			return vol->type() != ModelVolumeType::MODEL_PART || vol->supported_facets.empty();
			});

		MessageDialog dlg(GUI::wxGetApp().plater(),
			_L("Automatic painting will erase all currently painted areas.") + "\n\n" +
			_L("Are you sure you want to do it?") + "\n",
			_L("Warning"), wxICON_WARNING | wxYES | wxNO);

		if (not_painted || dlg.ShowModal() == wxID_YES) {
			Plater::TakeSnapshot snapshot(wxGetApp().plater(), _L("Automatic painting support points"));
			int mesh_id = -1.0f;
			for (ModelVolume* mv : mo->volumes) {
				if (mv->is_model_part()) {
					mesh_id++;
					mv->supported_facets.reset();
					m_triangle_selectors[mesh_id]->reset();
					m_triangle_selectors[mesh_id]->request_update_render_data();
				}
			}

			wxGetApp().CallAfter([this]() {
				wxGetApp().plater()->reslice_FFF_until_step(posSupportSpotsSearch, *m_c->selection_info()->model_object(), false);
				this->waiting_for_autogenerated_supports = true;
				});
		}
	}


	PainterGizmoType GLGizmoFdmSupports::get_painter_type() const
	{
		return PainterGizmoType::FDM_SUPPORTS;
	}

	wxString GLGizmoFdmSupports::handle_snapshot_action_name(bool shift_down, GLGizmoPainterBase::Button button_down) const
	{
		wxString action_name;
		if (shift_down)
			action_name = _L("Remove selection");
		else {
			if (button_down == Button::Left)
				action_name = _L("Add supports");
			else
				action_name = _L("Block supports");
		}
		return action_name;
	}

	void GLGizmoFdmSupports::on_opening()
	{
		set_input_window_state(true);
	}

	void GLGizmoFdmSupports::on_shutdown()
	{
		m_highlight_by_angle_threshold_deg = 0.f;
		m_parent.use_slope(false);

		m_parent.toggle_model_objects_visibility(true);

		set_input_window_state(false);
	}

	void GLGizmoFdmSupports::set_input_window_state(bool on)
	{
		if (wxGetApp().plater() == nullptr)
			return;

		ANKER_LOG_INFO << "GLGizmoFdmSupports: " << on;

		std::string panelFlag = "GLGizmoFdmSupports";
		if (on)
		{
			wxGetApp().plater()->sidebarnew().setMainSizer();

			if (m_pInputWindowSizer == nullptr)
			{
				double defaultSize = 2.0;
				double brushSizeMin = 0.4;
				double brushSizeMax = 8.0;
				int align_left = 2;
				int align_right = 8;
				char text[50];
				m_cursor_radius = defaultSize;
				m_pInputWindowSizer = new wxBoxSizer(wxVERTICAL);
				auto green_font_color = wxColour("#62D361");

				AnkerTitledPanel* container = new AnkerTitledPanel(&(wxGetApp().plater()->sidebarnew()), 46, 12);
				container->setTitle(wxString::FromUTF8(get_name(true, false)));
				container->setTitleAlign(AnkerTitledPanel::TitleAlign::LEFT);
				int returnBtnID = container->addTitleButton(wxString::FromUTF8(Slic3r::var("return.png")), true);
				int clearBtnID = container->addTitleButton(wxString::FromUTF8(Slic3r::var("reset.png")), false);
				m_pInputWindowSizer->Add(container, 1, wxEXPAND, 0);

				supportPanel = new wxPanel(container);
				supportPanel->SetMinSize(AnkerSize(SIDEBARNEW_WIDGET_WIDTH, 600));
				supportPanelSizer = new wxBoxSizer(wxVERTICAL);
				supportPanel->SetSizer(supportPanelSizer);
				container->setContentPanel(supportPanel);
				supportPanel->Bind(wxEVT_PAINT, [this](wxPaintEvent& event) {
					on_paint();
					});

				{
					wxBoxSizer* emptySizer = new wxBoxSizer(wxHORIZONTAL);
					supportPanelSizer->Add(emptySizer, 0, wxEXPAND | wxALIGN_TOP | wxLEFT | wxRIGHT, 10);
					emptySizer->Add(1, 10, wxALIGN_CENTER, 0); //empty item for enough height space
				}

				{
					// Overhang Thershold
					wxBoxSizer* thersholdSizer = new wxBoxSizer(wxHORIZONTAL);
					supportPanelSizer->Add(thersholdSizer, 0, wxEXPAND | wxALIGN_TOP | wxLEFT | wxRIGHT, 20);
					add_static_text(thersholdSizer, supportPanel, _L("common_slice_toolpannelsupport_overhang"), align_left);
					thersholdSizer->AddStretchSpacer(1);

					m_parent.use_slope(true);
					sprintf(text, "%.2f", m_selected_angle);
					thresholdTextCtrl = add_line_edit(thersholdSizer, supportPanel, text, _L("Â°"), wxSize(104, 25), align_right);
					thresholdTextCtrl->AddValidatorFloat(0.0, 90.0, 2);

					thresholdTextCtrl->Bind(wxEVT_TEXT, [this](wxCommandEvent& event) {
						wxString newValueStr = thresholdTextCtrl->getTextEdit()->GetLineText(0);
						bool success = newValueStr.ToDouble(&m_selected_angle);
						if (success && m_parent.is_using_slope()) {
							high_light_overhang_by_angle(m_selected_angle);
						}
						wxGetApp().sidebarnew().setItemValue(_L("Support"), _L("support_material_threshold"), m_selected_angle);   // todo change tab name
						});
				}

				{
					// Highlight Overhang
					wxBoxSizer* highlightSizer = new wxBoxSizer(wxHORIZONTAL);
					supportPanelSizer->Add(highlightSizer, 0, wxEXPAND | wxALIGN_TOP | wxLEFT | wxRIGHT, 20);
					add_static_text(highlightSizer, supportPanel, _L("common_slice_toolpannelsupport_highlight"), align_left);
					highlightSizer->Add(1, 30, wxALIGN_CENTER, 0); //just for enough height space
					highlightSizer->AddStretchSpacer(1);

					highLightButton = add_switch_button(highlightSizer, supportPanel, align_right);
					highLightButton->SetSelected(true);
					highLightButton->Bind(wxEVT_BUTTON, [this](wxCommandEvent& event) {
						auto selected = highLightButton->GetSelected();
						if (selected) {
							m_parent.use_slope(true);
							high_light_overhang_by_angle(m_selected_angle);
						}
						else {
							m_parent.use_slope(false);
						}
						});
				}

				{
					// Support On Build Plate Only
					wxBoxSizer* buildPlateSizer = new wxBoxSizer(wxHORIZONTAL);
					supportPanelSizer->Add(buildPlateSizer, 0, wxEXPAND | wxALIGN_TOP | wxLEFT | wxRIGHT, 20);
					add_static_text(buildPlateSizer, supportPanel, _L("common_slice_toolpannelsupport_bulid"), align_left);
					buildPlateSizer->Add(1, 30, wxALIGN_CENTER, 0);
					buildPlateSizer->AddStretchSpacer(1);
					buildPlateButton = add_switch_button(buildPlateSizer, supportPanel, align_right);
					buildPlateButton->Bind(wxEVT_BUTTON, [this](wxCommandEvent& event) {
						auto selected = buildPlateButton->GetSelected();
						wxGetApp().sidebarnew().setItemValue(_L("Support"), _L("support_material_buildplate_only"), selected);  // todo change tab name
						});
				}

				{
					// Style
					wxBoxSizer* styleSizer = new wxBoxSizer(wxHORIZONTAL);
					//styleSizer->Add(0, 30);
					supportPanelSizer->Add(styleSizer, 0, wxEXPAND | wxALIGN_TOP | wxLEFT | wxRIGHT, 20);
					add_static_text(styleSizer, supportPanel, _L("Style"), align_left);
					styleSizer->AddStretchSpacer(1);


					// combox
					wxArrayString  itemList = {};
					wxStringList dataList = {};
					Slic3r::GUI::wxGetApp().plater()->sidebarnew().getItemList(dataList, ControlListType::List_Style);
					for (size_t i = 0; i < dataList.GetCount(); i++)
						itemList.Add(dataList[i]);

					wxImage dropBtnImage(wxString::FromUTF8(Slic3r::var("drop_down.png")), wxBITMAP_TYPE_PNG);
					dropBtnImage.Rescale(8, 8, wxIMAGE_QUALITY_HIGH);
					wxBitmapBundle dropBtnBmpNormal = wxBitmapBundle::FromBitmap(wxBitmap(dropBtnImage));
					wxBitmapBundle dropBtnBmpPressed = wxBitmapBundle::FromBitmap(wxBitmap(dropBtnImage));
					wxBitmapBundle dropBtnBmpHover = wxBitmapBundle::FromBitmap(wxBitmap(dropBtnImage));

					AnkerSimpleCombox* styleChoice = new AnkerSimpleCombox();
					styleChoice->Create(supportPanel, wxID_ANY, wxEmptyString, wxDefaultPosition, wxDefaultSize, itemList, wxNO_BORDER | wxCB_READONLY);
					styleChoice->SetButtonBitmaps(dropBtnBmpNormal, true, dropBtnBmpPressed, dropBtnBmpHover);
					styleChoice->SetBackgroundColour(wxColour("#292A2D"));
					styleChoice->setColor(wxColour("#434447"), wxColour("#3A3B3F"));
					styleChoice->SetMinSize(AnkerSize(104, 24));
					styleChoice->SetSize(AnkerSize(104, 24));

					styleChoice->Bind(wxEVT_COMBOBOX, [styleChoice](wxCommandEvent& event) {
						// update style to parameter panel, not preset panel
						wxGetApp().sidebarnew().setItemValue(_L("Support"), _L("support_material_style"), styleChoice->GetSelection()); // todo change tab name
						});
					styleSizer->Add(styleChoice, 0, wxALIGN_RIGHT | wxCENTER | wxTOP, align_right);
					m_styleChoice = styleChoice;
				}

				{
					// Support Material
					wxBoxSizer* supportMaterialSizer = new wxBoxSizer(wxHORIZONTAL);
					supportPanelSizer->Add(supportMaterialSizer, 0, wxEXPAND | wxALIGN_TOP | wxLEFT | wxRIGHT, 20);
					supportMaterialText = add_static_text(supportMaterialSizer, supportPanel, _L("common_slice_toolpannelsupport_supportmaterial"), align_left);
					supportMaterialSizer->AddStretchSpacer(1);
					supportMaterialButton = add_filament_item(supportPanel, AnkerSize(20, 20), 1, wxColor(*wxWHITE), true);
					supportMaterialButton->SetLabelText(_L("Support material/raft/skirt extruder"));
					supportMaterialButton->SetName(_L("support_material_extruder"));
					supportMaterialSizer->Add(supportMaterialButton, 0, wxALIGN_RIGHT | wxCENTER | wxTOP, align_right);

					// Top Surface Material
					wxBoxSizer* topSurfaceMaterialSizer = new wxBoxSizer(wxHORIZONTAL);
					supportPanelSizer->Add(topSurfaceMaterialSizer, 0, wxEXPAND | wxALIGN_TOP | wxLEFT | wxRIGHT, 20);
					topSurfaceMaterialText = add_static_text(topSurfaceMaterialSizer, supportPanel, _L("common_slice_toolpannelsupport_surfacematerial"), align_left);
					topSurfaceMaterialSizer->AddStretchSpacer(1);
					topSurfaceMaterialButton = add_filament_item(supportPanel, AnkerSize(20, 20), 2, wxColor(*wxLIGHT_GREY), true);
					topSurfaceMaterialButton->SetLabelText(_L("Support material/raft interface extruder"));
					topSurfaceMaterialButton->SetName(_L("support_material_interface_extruder"));
					topSurfaceMaterialSizer->Add(topSurfaceMaterialButton, 0, wxALIGN_RIGHT | wxCENTER | wxTOP, align_right);

				}

				{
					// More Setting
					wxBoxSizer* moreSettingSizer = new wxBoxSizer(wxHORIZONTAL);
					supportPanelSizer->Add(moreSettingSizer, 0, wxEXPAND | wxALIGN_TOP | wxLEFT | wxRIGHT, 24);
					AnkerBtn* moreSettingButton = add_button(moreSettingSizer, supportPanel, align_left, wxSize(100, 25));
					moreSettingButton->SetText(_L("common_slice_toolpannelsupport_more"));
					moreSettingButton->SetTextColor(green_font_color);
					moreSettingButton->Bind(wxEVT_BUTTON, [this](wxCommandEvent) {
						wxGetApp().plater()->get_current_canvas3D()->force_main_toolbar_left_action(wxGetApp().plater()->get_current_canvas3D()->get_main_toolbar_item_id(get_name(false, false)));
						wxGetApp().sidebarnew().openSupportMaterialPage(_L("common_slicepannel_style11_expert"),_L("Support"));
						});

					moreSettingSizer->Add(1, 30, wxALIGN_CENTER, 0); //just for enough height space

				}

				AnkerSplitCtrl* splitCtrl = new AnkerSplitCtrl(supportPanel);
				splitCtrl->SetMaxSize(AnkerSize(100000, 1));
				splitCtrl->SetMinSize(AnkerSize(1, 1));
				supportPanelSizer->Add(splitCtrl, 0, wxEXPAND | wxALIGN_CENTER | wxTOP | wxBOTTOM, 10);

				{// Generate Support
					wxBoxSizer* enforceSizer = new wxBoxSizer(wxHORIZONTAL);
					supportPanelSizer->Add(enforceSizer, 0, wxEXPAND | wxALIGN_TOP | wxLEFT | wxRIGHT, 20);
					{
						auto staticText = add_static_text(enforceSizer, supportPanel, _L("common_slice_toolpannelsupport_title1"), align_left);
						staticText->SetFont(ANKER_BOLD_FONT_NO_1);
					}
					enforceSizer->AddStretchSpacer(1);

					AnkerBtn* enforceButton = add_button(enforceSizer, supportPanel, align_right, wxSize(102, 25));
					enforceButton->SetText(_L("common_slice_toolpannelsupport_buttonenforce"));
					enforceButton->SetTextColor(green_font_color);
					enforceButton->Bind(wxEVT_BUTTON, [this, enforceButton](wxCommandEvent& event) {
						select_facets_by_angle(m_selected_angle, false);

						//set generate support material on
						wxGetApp().sidebarnew().setItemValue(_L("Support"), _L("support_material"), true); // todo change tab name
						});
				}

				AnkerSplitCtrl* splitCtrl2 = new AnkerSplitCtrl(supportPanel);
				splitCtrl2->SetMaxSize(AnkerSize(100000, 1));
				splitCtrl2->SetMinSize(AnkerSize(1, 1));
				supportPanelSizer->Add(splitCtrl2, 0, wxEXPAND | wxALIGN_CENTER | wxTOP | wxBOTTOM, 10);

				// Mannual Painting
				wxBoxSizer* mannualSizer = new wxBoxSizer(wxHORIZONTAL);
				supportPanelSizer->Add(mannualSizer, 0, wxEXPAND | wxALIGN_TOP | wxLEFT | wxRIGHT, 20);
				{
					auto staticText = add_static_text(mannualSizer, supportPanel, _L("common_slice_toolpannelsupport_painting"), align_left);
					staticText->SetForegroundColour(wxColour(*wxWHITE));
					staticText->SetFont(ANKER_BOLD_FONT_NO_1);
					wxBoxSizer* emptySizer = new wxBoxSizer(wxHORIZONTAL);
					supportPanelSizer->Add(emptySizer, 0, wxEXPAND | wxALIGN_TOP | wxLEFT | wxRIGHT, 20);
					emptySizer->Add(1, 10, wxALIGN_CENTER, 0); //empty item for enough height space
				}

				{
					// Brush Size Text
					wxBoxSizer* brushSizer = new wxBoxSizer(wxHORIZONTAL);
					supportPanelSizer->Add(brushSizer, 0, wxEXPAND | wxALIGN_TOP | wxLEFT | wxRIGHT, 20);
					add_static_text(brushSizer, supportPanel, _L("common_slice_toolpanneldraw_title2"), align_left);

					// Brush Sizer
					wxBoxSizer* brushSliderSizer = new wxBoxSizer(wxHORIZONTAL);
					supportPanelSizer->Add(brushSliderSizer, 0, wxEXPAND | wxALIGN_CENTER | wxLEFT | wxRIGHT, 18);

					// Brush Slider
					brushSlider = new AnkerSlider(supportPanel);
					brushSlider->SetBackgroundColour(wxColour(PANEL_BACK_RGB_INT));
					brushSlider->SetMinSize(AnkerSize(40, 24));
					brushSlider->SetMaxSize(AnkerSize(1000, 24));
					brushSlider->setRange(brushSizeMin, brushSizeMax, 0.01);
					brushSlider->setCurrentValue(defaultSize);
					brushSlider->setTooltipVisible(false);
					brushSliderSizer->Add(brushSlider, 1, wxEXPAND | wxALIGN_LEFT | wxTOP, 8);

					sprintf(text, "%.2f", defaultSize);
					AnkerLineEditUnit* brushTextCtrl = add_line_edit(brushSliderSizer, supportPanel, text, _L(""), wxSize(40, 25), align_right);
					brushTextCtrl->AddValidatorFloat(brushSizeMin, brushSizeMax, 2);

					bind_slider_and_text(*brushSlider, *brushTextCtrl->getTextEdit(), [this](float value) {
						m_cursor_radius = value;
						});

					{
						wxBoxSizer* emptySizer = new wxBoxSizer(wxHORIZONTAL);
						supportPanelSizer->Add(emptySizer, 0, wxEXPAND | wxALIGN_TOP | wxLEFT | wxRIGHT, 10);
						emptySizer->Add(1, 10, wxALIGN_CENTER, 0); //empty item for enough height space
					}
				}

				{
					// Clipping Of View Text
					wxBoxSizer* clippingSizer = new wxBoxSizer(wxHORIZONTAL);
					supportPanelSizer->Add(clippingSizer, 0, wxEXPAND | wxALIGN_TOP | wxLEFT | wxRIGHT, 20);
					add_static_text(clippingSizer, supportPanel, _L("common_slice_toolpannelsupport_view"), align_left);

					// Clipping Sizer
					wxBoxSizer* clippingSliderSizer = new wxBoxSizer(wxHORIZONTAL);
					supportPanelSizer->Add(clippingSliderSizer, 0, wxEXPAND | wxALIGN_CENTER | wxLEFT | wxRIGHT, 18);

					// Clipping Slider
					float minClip = 0.0;
					float maxClip = 1.0;
					clippingSlider = new AnkerSlider(supportPanel);
					clippingSlider->SetBackgroundColour(wxColour(PANEL_BACK_RGB_INT));
					clippingSlider->SetMinSize(AnkerSize(40, 24));
					clippingSlider->SetMaxSize(AnkerSize(1000, 24));
					clippingSlider->setRange(minClip, maxClip, 0.01);
					clippingSlider->setCurrentValue(0.0);
					clippingSlider->setTooltipVisible(false);
					clippingSliderSizer->Add(clippingSlider, 1, wxEXPAND | wxALIGN_LEFT | wxTOP, 8);

					sprintf(text, "%.2f", 0.0);
					AnkerLineEditUnit* clippingSliderTextCtrl = add_line_edit(clippingSliderSizer, supportPanel, text, _L(""), wxSize(40, 25), align_right);
					clippingSliderTextCtrl->AddValidatorFloat(0.0, 1.0, 2);

					bind_slider_and_text(*clippingSlider, *clippingSliderTextCtrl->getTextEdit(), [this](float clp_dist) {
						if (m_c->object_clipper()) {
							m_c->object_clipper()->set_position_by_ratio(clp_dist, true);
						}
						});

					{
						wxBoxSizer* emptySizer = new wxBoxSizer(wxHORIZONTAL);
						supportPanelSizer->Add(emptySizer, 0, wxEXPAND | wxALIGN_TOP | wxLEFT | wxRIGHT, 20);
						emptySizer->Add(1, 10, wxALIGN_CENTER, 0); //empty item for enough height space
					}
				}

				supportPanelSizer->AddStretchSpacer(1);


				container->Bind(wxANKEREVT_ATP_BUTTON_CLICKED, [this, returnBtnID, clearBtnID](wxCommandEvent& event) {
					int btnID = event.GetInt();
					if (btnID == returnBtnID)
					{
						wxGetApp().plater()->get_current_canvas3D()->force_main_toolbar_left_action(wxGetApp().plater()->get_current_canvas3D()->get_main_toolbar_item_id(get_name(false, false)));
					}
					else if (btnID == clearBtnID)
					{
						reset();
					}
					});

				wxGetApp().plater()->sidebarnew().Bind(wxCUSTOMEVT_MAIN_SIZER_CHANGED, [this, panelFlag](wxCommandEvent& event) {
					event.Skip();

					if (!m_panelVisibleFlag)
						return;

					std::string flag = wxGetApp().plater()->sidebarnew().getSizerFlags().ToStdString();
					if (flag != panelFlag)
					{
						m_panelVisibleFlag = false;

						wxGetApp().plater()->get_current_canvas3D()->force_main_toolbar_left_action(wxGetApp().plater()->get_current_canvas3D()->get_main_toolbar_item_id(get_name(false, false)));
					}
					});
			}

			wxGetApp().plater()->sidebarnew().replaceUniverseSubSizer(m_pInputWindowSizer, panelFlag);
			sync_data_from_param_panel();
			m_panelVisibleFlag = true;
        }
		else
		{
		    m_panelVisibleFlag = false;
		    if (wxGetApp().plater()->sidebarnew().getSizerFlags() == panelFlag)
			{
				wxGetApp().plater()->sidebarnew().replaceUniverseSubSizer();
			}
		}
	}

	wxStaticText* GLGizmoFdmSupports::add_static_text(wxBoxSizer* sizer, wxPanel* panel, wxString textStr, int align)
	{
		wxStaticText* staticText = new wxStaticText(panel, wxID_ANY, textStr, wxDefaultPosition, wxDefaultSize, wxNO_BORDER);
		staticText->SetFont(ANKER_FONT_NO_1);
		staticText->SetBackgroundColour(wxColour(PANEL_BACK_RGB_INT));
		staticText->SetForegroundColour(wxColour(TEXT_DARK_RGB_INT));
		sizer->Add(staticText, 0, wxALIGN_LEFT | wxLEFT | wxCENTER | wxTOP, align);
		return staticText;
	}

	AnkerLineEditUnit* GLGizmoFdmSupports::add_line_edit(wxBoxSizer* sizer, wxPanel* panel, wxString textStr, wxString unit, wxSize size, int align)
	{
		size = AnkerSize(size.x, size.y);
		AnkerLineEditUnit* item = new AnkerLineEditUnit(supportPanel, unit, ANKER_FONT_NO_1, wxColour(41, 42, 45), wxColour("#3F4043"), 4, wxID_ANY);
		item->setLineEditFont(ANKER_FONT_NO_1);
		item->SetMaxSize(size);
		item->SetMinSize(size);
		item->SetSize(size);
		item->setValue(textStr);
		sizer->Add(item, 0, wxALIGN_RIGHT | wxCENTER | wxTOP, align);
		return item;
	}

	AnkerBtn* GLGizmoFdmSupports::add_button(wxBoxSizer* sizer, wxPanel* panel, int align, wxSize size, wxBitmap* bitImage, wxBitmap* hoverImage, bool should_handle_mousemove)
	{
		size = AnkerSize(size.x, size.y);
		auto bgColor = wxColour("#333438");
		auto bgHoverColor = wxColour("#324435");
		AnkerBtn* button = new AnkerBtn(panel, wxID_ANY, wxDefaultPosition, wxDefaultSize, wxNO_BORDER);
		button->SetMinSize(size);
		button->SetMaxSize(size);
		button->SetSize(size);
		button->SetFont(ANKER_FONT_NO_1);
		button->SetName(BTN_NORMAL);
		button->SetRadius(3);
		button->SetBackgroundColour(bgColor);
		sizer->Add(button, 0, wxALIGN_RIGHT | wxCENTER | wxTOP | wxBOTTOM, align);
		if (bitImage)
		{
			button->SetNorImg(bitImage);
		}
		button->Bind(wxEVT_ENTER_WINDOW, [button, hoverImage, should_handle_mousemove, bgHoverColor](wxMouseEvent& event) {
			if (!should_handle_mousemove) return;
			if (hoverImage)
				button->SetNorImg(hoverImage);
			button->SetBackgroundColour(bgHoverColor);
			button->Refresh();
			});
		button->Bind(wxEVT_LEAVE_WINDOW, [button, bgColor, bitImage, should_handle_mousemove](wxMouseEvent& event) {
			if (!should_handle_mousemove) return;
			if (bitImage)
				button->SetNorImg(bitImage);
			button->SetBackgroundColour(bgColor);
			button->Refresh();
			});

		return button;
	}

	AnkerSwitchButton* GLGizmoFdmSupports::add_switch_button(wxBoxSizer* sizer, wxPanel* panel, int align)
	{
		wxImage open_image(wxString::FromUTF8(Slic3r::var("fdm_switch_open.png")), wxBITMAP_TYPE_PNG);
		wxImage close_image(wxString::FromUTF8(Slic3r::var("fdm_switch_close.png")), wxBITMAP_TYPE_PNG);
		wxBitmap open_bitmap(open_image);
		wxBitmap close_bitmap(close_image);
		auto size = open_image.GetSize();

		AnkerSwitchButton* button = new AnkerSwitchButton(panel, close_bitmap);
		button->SetMinSize(size);
		button->SetActieBitMap(open_bitmap);
		sizer->Add(button, 0, wxALIGN_RIGHT | wxCENTER | wxTOP | wxBOTTOM, align);
		sizer->Layout();
		return button;
	}

	AnkerTextBtn* GLGizmoFdmSupports::add_filament_item(wxPanel* panel, wxSize size, int filamentIndex, wxColour filamentColor, bool filamentVisible)
	{
		AnkerTextBtn* newItem = new AnkerTextBtn(panel);
		newItem->SetMinSize(size);
		newItem->SetMaxSize(size);
		newItem->SetSize(size);
		newItem->setText(wxString::Format(wxT("%d"), filamentIndex));
		newItem->SetBackgroundColour(wxColour("#292A2D"));
		newItem->Bind(wxCUSTOMEVT_ANKER_BTN_CLICKED, &GLGizmoFdmSupports::handle_item_filament_clicked, this, -1, -1);
		return newItem;
	}

	void GLGizmoFdmSupports::bind_slider_and_text(AnkerSlider& slider, wxRichTextCtrl& textCtrl, std::function<void(float)> func)
	{
		slider.Bind(wxANKEREVT_SLIDER_VALUE_CHANGED, [this, &textCtrl, &slider, func](wxCommandEvent& event) {
			double currentValue = slider.getCurrentValue();
			double value = currentValue;
			char text[5];
			sprintf(text, "%.2f", currentValue);
			textCtrl.SetValue(text);
			func(value);
			});
		textCtrl.Bind(wxCUSTOMEVT_EDIT_FINISHED, [this, &slider, &textCtrl, func](wxCommandEvent& event) {
			double newValue = 10.0;
			wxString newValueStr = textCtrl.GetLineText(0);
			bool success = newValueStr.ToDouble(&newValue);
			if (success)
			{
				slider.setCurrentValue(newValue);
				slider.Refresh();
				func(newValue);
			}
			});
	}

	void GLGizmoFdmSupports::high_light_overhang_by_angle(float angle)
	{
		m_parent.set_slope_normal_angle(90.f - angle);
		if (!m_parent.is_using_slope()) {
			m_parent.use_slope(true);
			m_parent.set_as_dirty();
		}
	}

	void GLGizmoFdmSupports::handle_item_filament_clicked(wxCommandEvent& event)
	{
		AnkerTextBtn* targetItem = wxDynamicCast(event.GetEventObject(), AnkerTextBtn);
		std::vector<std::pair<wxColour, wxString>> contentList;
		const std::vector<Slic3r::GUI::SFilamentInfo>& filamentInfos = Slic3r::GUI::wxGetApp().plater()->sidebarnew().getEditFilamentList();
		int infoSize = filamentInfos.size();
		for (int i = 0; i < infoSize; i++)
		{
			contentList.push_back({ wxColour(filamentInfos[i].wxStrColor), filamentInfos[i].wxStrLabelType });
		}
		auto floatinglist = Slic3r::GUI::wxGetApp().floatinglist();
		auto size = floatinglist->GetSize();
		floatinglist->Move(targetItem->GetScreenPosition() - wxPoint(size.x, 0));
		floatinglist->setContentList(contentList);
		floatinglist->Show();
		floatinglist->Raise();
		floatinglist->SetFocus();
		int filamentIndex;
		targetItem->GetText().ToInt(&filamentIndex);
		if (filamentIndex <= 0) filamentIndex = 1;
		if (filamentIndex > floatinglist->length()) filamentIndex = floatinglist->length();
		floatinglist->setCurrentSelection(filamentIndex - 1);

		floatinglist->setItemClickCallback([this, targetItem, floatinglist, infoSize](int index) {
			floatinglist->Hide();
			int currentIndex = floatinglist->getCurrentSelectionIndex();
			std::pair<wxColour, wxString> currentSelection = floatinglist->getItemContent(currentIndex);
			targetItem->setText(wxString::Format(wxT("%d"), currentIndex + 1));
			targetItem->setForegroundColour(currentSelection.first);

			wxGetApp().sidebarnew().setItemValue(_L("Multiple Extruders"), targetItem->GetLabelText(), currentIndex + 1); // todo change tab name
			//update preset config
			auto& printConfig = Slic3r::GUI::wxGetApp().preset_bundle->prints.get_edited_preset().config;
			printConfig.set_key_value(targetItem->GetName().ToStdString(), new ConfigOptionInt(currentIndex + 1));
			wxGetApp().plater()->on_config_change(printConfig);
			});
	}

	void GLGizmoFdmSupports::sync_data_from_param_panel()
	{
		auto printConfig = wxGetApp().preset_bundle->full_config();
		wxGetApp().sidebarnew().updatePreset(printConfig);
		// set overhang thershold
		double angle = printConfig.opt_int("support_material_threshold");
		char text[50];
		sprintf(text, "%.2f", angle);
		thresholdTextCtrl->SetValue(text);
		// set support on build plate only 
		bool isBuildPlateOnly = printConfig.opt_bool("support_material_buildplate_only");
		buildPlateButton->SetSelected(isBuildPlateOnly);
		// set style
		auto support_material_style_value = printConfig.opt_enum<Slic3r::SupportMaterialStyle>("support_material_style");
		m_styleChoice->SetSelection(support_material_style_value);

		// set support material extruder
		int multi_filaments = Slic3r::GUI::wxGetApp().preset_bundle->filament_presets.size() > 1;
		if (multi_filaments)
		{
			supportMaterialText->Show();
			supportMaterialButton->Show();
			topSurfaceMaterialText->Show();
			topSurfaceMaterialButton->Show();
			auto floatinglist = Slic3r::GUI::wxGetApp().floatinglist();
			const auto& filamentInfos = Slic3r::GUI::wxGetApp().plater()->sidebarnew().getEditFilamentList();
			auto currentIndex = printConfig.opt_int("support_material_extruder");
			if (currentIndex < 1) currentIndex = 1;
			if (currentIndex > filamentInfos.size()) currentIndex = filamentInfos.size();
			//supportMaterialButton->setFilament(currentIndex, filamentInfos[currentIndex-1].wxStrColor);
			supportMaterialButton->setText(wxString::Format(wxT("%d"), currentIndex));
			supportMaterialButton->setForegroundColour(filamentInfos[currentIndex - 1].wxStrColor);
			currentIndex = printConfig.opt_int("support_material_interface_extruder");
			if (currentIndex < 1) currentIndex = 1;
			if (currentIndex > filamentInfos.size()) currentIndex = filamentInfos.size();
			//topSurfaceMaterialButton->setFilament(currentIndex, filamentInfos[currentIndex - 1].wxStrColor);
			topSurfaceMaterialButton->setText(wxString::Format(wxT("%d"), currentIndex));
			topSurfaceMaterialButton->setForegroundColour(filamentInfos[currentIndex - 1].wxStrColor);
		}
		else {
			supportMaterialText->Hide();
			supportMaterialButton->Hide();
			topSurfaceMaterialText->Hide();
			topSurfaceMaterialButton->Hide();
		}
		supportPanel->Fit();
		supportPanelSizer->Layout();

		if (highLightButton->GetName() == BTN_NORMAL) // siwtch on
		{
			m_parent.use_slope(true);
			m_parent.set_as_dirty();
		}

	}

	//reset all to default value, this function will change parameter panel's data
	void GLGizmoFdmSupports::reset()
	{
		Plater::TakeSnapshot snapshot(wxGetApp().plater(), _L("Reset selection"), UndoRedo::SnapshotType::GizmoAction);
		ModelObject* mo = m_c->selection_info()->model_object();
		int                  idx = -1;
		for (ModelVolume* mv : mo->volumes)
			if (mv->is_model_part()) {
				++idx;
				m_triangle_selectors[idx]->reset();
				m_triangle_selectors[idx]->request_update_render_data();
			}

		update_model_object();
		m_parent.use_slope(true);
		m_parent.set_as_dirty();
		this->waiting_for_autogenerated_supports = false;

		int multi_filaments = Slic3r::GUI::wxGetApp().preset_bundle->filament_presets.size() > 1;
		if (multi_filaments) {
			auto floatinglist = Slic3r::GUI::wxGetApp().floatinglist();
			const auto& filamentInfos = Slic3r::GUI::wxGetApp().plater()->sidebarnew().getEditFilamentList();
			supportMaterialButton->setText(L"1");
			supportMaterialButton->setForegroundColour(filamentInfos[0].wxStrColor);
			wxGetApp().sidebarnew().setItemValue(_L("Multiple Extruders"), supportMaterialButton->GetLabelText(), 1);
			topSurfaceMaterialButton->setText(L"1");
			topSurfaceMaterialButton->setForegroundColour(filamentInfos[0].wxStrColor);
			wxGetApp().sidebarnew().setItemValue(_L("Multiple Extruders"), topSurfaceMaterialButton->GetLabelText(), 1); // todo change tab name
		}
		else {
			supportMaterialText->Hide();
			supportMaterialButton->Hide();
			topSurfaceMaterialText->Hide();
			topSurfaceMaterialButton->Hide();
		}
		supportPanel->Fit();
		supportPanelSizer->Layout();

		auto printConfig = wxGetApp().preset_bundle->full_config();
		double angle = printConfig.opt_int("support_material_threshold");
		char text[50];
		sprintf(text, "%.2f", angle);
		thresholdTextCtrl->SetValue(text);
		highLightButton->SetSelected(true);

		// set support on build plate only 
		bool isBuildPlateOnly = printConfig.opt_bool("support_material_buildplate_only");
		buildPlateButton->SetSelected(isBuildPlateOnly);
		// set style
		auto support_material_style_value = printConfig.opt_enum<Slic3r::SupportMaterialStyle>("support_material_style");
		m_styleChoice->SetSelection(support_material_style_value);

		set_slider_value(brushSlider, 2.0);
		set_slider_value(clippingSlider, 0.0);

		//set generate support material off
		wxGetApp().sidebarnew().setItemValue(_L("Support"), _L("support_material"), false); // todo change tab name
	}

	void GLGizmoFdmSupports::set_button_state(AnkerBtn* button, wxString state)
	{
		button->SetName(state);
		wxCommandEvent event(wxEVT_COMMAND_BUTTON_CLICKED, button->GetId());
		button->GetEventHandler()->ProcessEvent(event);
	}

	void GLGizmoFdmSupports::set_slider_value(AnkerSlider* slider, double value)
	{
		slider->setCurrentValue(value);
		wxCommandEvent event(wxANKEREVT_SLIDER_VALUE_CHANGED, slider->GetId());
		slider->GetEventHandler()->ProcessEvent(event);
	}

	void GLGizmoFdmSupports::on_paint()
	{
		m_pInputWindowSizer->Layout();
		supportPanel->Refresh();
		
	}

} // namespace Slic3r::GUI
