#ifndef slic3r_GLGizmoFdmSupports_hpp_
#define slic3r_GLGizmoFdmSupports_hpp_

#include "GLGizmoPainterBase.hpp"

#include "slic3r/GUI/I18N.hpp"
#include "slic3r/GUI/AnkerBtn.hpp"
#include "slic3r/GUI/Common/AnkerSliderCtrl.hpp"
#include "slic3r/GUI/Common/AnkerSimpleCombox.hpp"
#include "slic3r/GUI/AnkerObjectBarView.hpp"
#include "slic3r/GUI/Common/AnkerLineEditUnit.hpp"
#include "slic3r/GUI/Common/AnkerSwitchButton.hpp"

namespace Slic3r::GUI {

class GLGizmoFdmSupports : public GLGizmoPainterBase
{
public:
    GLGizmoFdmSupports(GLCanvas3D& parent, const std::string& icon_filename, unsigned int sprite_id);

    void render_painter_gizmo() override;

    void reset();

protected:
    void on_render_input_window(float x, float y, float bottom_limit) override;
    std::string on_get_name(bool i18n = true) const override;

    wxString handle_snapshot_action_name(bool shift_down, Button button_down) const override;

    std::string get_gizmo_entering_text() const override { return _u8L("Entering Paint-on supports"); }
    std::string get_gizmo_leaving_text() const override { return _u8L("Leaving Paint-on supports"); }
    std::string get_action_snapshot_name() const override { return _u8L("Paint-on supports editing"); }


private:
    bool on_init() override;
    void data_changed(bool is_serializing) override;

    void update_model_object() const override;
    void update_from_model_object() override;

    void on_opening() override;
    void on_shutdown() override;
    // BBS
    void on_set_state() override;
    PainterGizmoType get_painter_type() const override;

    void select_facets_by_angle(float threshold, bool block);

    void sync_data_from_param_panel();

#ifdef WX_UI
    // Anker
    void set_input_window_state(bool on);

    wxStaticText* add_static_text(wxBoxSizer* sizer, wxPanel* panel, wxString textStr, int align);
    AnkerLineEditUnit* add_line_edit(wxBoxSizer* sizer, wxPanel* panel, wxString textStr, wxString unit, wxSize size, int align);
    AnkerBtn* add_button(wxBoxSizer* sizer, wxPanel* panel, int align, wxSize size, wxBitmap* bitImage = nullptr, wxBitmap* hoverImage = nullptr, bool should_handle_mousemove = true);
    AnkerSwitchButton* add_switch_button(wxBoxSizer* sizer, wxPanel* panel, int align);
    AnkerTextBtn* add_filament_item(wxPanel* panel, wxSize size, int filamentIndex, wxColour filamentColor, bool filamentVisible)
    void btn_bind_press_event(AnkerBtn* button, wxBitmap* bitImage, wxBitmap* pressedImage, std::function<void(bool)> func);
    void bind_slider_and_text(AnkerSlider& slider, wxRichTextCtrl& textCtrl, std::function<void(float)> func);
    void high_light_overhang_by_angle(float angle);
    void handle_item_filament_clicked(wxCommandEvent& event);
    void set_button_state(AnkerBtn* button, wxString state);
    void set_slider_value(AnkerSlider* slider, double value);
    void on_paint();
#endif

    // This map holds all translated description texts, so they can be easily referenced during layout calculations
    // etc. When language changes, GUI is recreated and this class constructed again, so the change takes effect.
    std::map<std::string, wxString> m_desc;
    
    // BBS
    bool m_is_dark_mode = true;
    wchar_t m_current_tool = 0;
    int m_support_threshold_angle = -1;
    EnforcerBlockerType m_currentType;
    const double default_selected_angle = 55.0;
    double m_selected_angle = default_selected_angle;

#ifdef WX_UI
    bool m_panelVisibleFlag;
    wxPanel* supportPanel = nullptr;
    wxBoxSizer* supportPanelSizer = nullptr;
    wxBoxSizer* m_pInputWindowSizer = nullptr;
    AnkerSimpleCombox* m_styleChoice = nullptr;
    AnkerLineEditUnit* thresholdTextCtrl = nullptr;
    AnkerSwitchButton* buildPlateButton = nullptr;
    wxStaticText* supportMaterialText = nullptr;
    AnkerTextBtn* supportMaterialButton = nullptr;
    wxStaticText* topSurfaceMaterialText = nullptr;
    AnkerTextBtn* topSurfaceMaterialButton = nullptr;
    AnkerSlider* brushSlider = nullptr;
    AnkerSlider* clippingSlider = nullptr;
    AnkerSwitchButton* highLightButton = nullptr;
#endif

    bool waiting_for_autogenerated_supports = false;
    bool has_backend_supports();
    void auto_generate();
    void apply_data_from_backend();
};



} // namespace Slic3r::GUI


#endif // slic3r_GLGizmoFdmSupports_hpp_
